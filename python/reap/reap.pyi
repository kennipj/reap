from __future__ import annotations

from os import PathLike
from typing import Literal

class Rectangle:
    top: float
    left: float
    bottom: float
    right: float

    def __init__(
        self, top: float, left: float, bottom: float, right: float
    ) -> None: ...
    def with_coords(
        self,
        *,
        top: float | None = None,
        left: float | None = None,
        bottom: float | None = None,
        right: float | None = None,
    ) -> Rectangle: ...
    def with_top(self, top: float) -> Rectangle: ...
    def with_left(self, left: float) -> Rectangle: ...
    def with_bottom(self, bottom: float) -> Rectangle: ...
    def with_right(self, right: float) -> Rectangle: ...
    def with_margin(
        self,
        *,
        top: float = 0.0,
        bottom: float = 0.0,
        left: float = 0.0,
        right: float = 0.0,
    ) -> Rectangle: ...
    def expand(
        self,
        rectangles: list[Rectangle],
        directions: list[Literal["up", "down", "left", "right"]],
        maximum_bounds: Rectangle,
    ) -> Rectangle: ...
    def get_center(self) -> tuple[float, float]: ...
    def overlap_percentage(self, other: Rectangle) -> float: ...
    def overlaps_horizontally(self, other: Rectangle) -> bool: ...
    def contains_left_side(self, other: Rectangle) -> bool: ...
    def overlaps(self, other: Rectangle, pct: float = 0.0) -> bool: ...
    def validate(self) -> bool: ...
    def overlaps_with_margins(
        self,
        other: Rectangle,
        top: float = 0.0,
        bottom: float = 0.0,
        left: float = 0.0,
        right: float = 0.0,
    ) -> bool: ...
    def vertical_overlap(self, other: Rectangle, threshold: float) -> bool: ...
    def distance(self, other: Rectangle) -> float: ...
    def corner(
        self,
        left_right: Literal["left", "right"],
        top_bottom: Literal["top", "bottom"],
    ) -> Point: ...

class Point:
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    def distance(self, other: Point) -> float: ...

class TextBlock:
    @property
    def rect(self) -> Rectangle: ...
    @property
    def text(self) -> str: ...
    def __init__(self, rect: Rectangle, text: str) -> None: ...

class TextChar:
    @property
    def rect(self) -> Rectangle: ...
    @property
    def ch(self) -> str: ...

class TextBlockIndex:
    def __init__(
        self,
        data: str | bytes | bytearray | memoryview | PathLike[str],
        include_chars: bool = False,
        password: str | bytes | bytearray | memoryview | None = None,
    ) -> None: ...
    @classmethod
    def from_path(
        cls,
        path: str | PathLike[str],
        include_chars: bool = False,
        password: str | bytes | bytearray | memoryview | None = None,
    ) -> TextBlockIndex: ...
    def search(self, rect: Rectangle, overlap: float) -> list[TextBlock]: ...
    def search_regex(self, pattern: str) -> list[TextBlock]: ...
    def scoped(
        self,
        rect: Rectangle,
        overlap: float = 0.0,
        merge_threshold: float = 0.0,
        normalize: bool = False,
        no_numeric_pair_merge: bool = False,
        no_date_pair_merge: bool = False,
    ) -> TextBlockIndex: ...
    @property
    def text(self) -> str: ...
    @property
    def text_blocks(self) -> list[TextBlock]: ...
    @property
    def doc_rect(self) -> Rectangle: ...
    @property
    def chars(self) -> list[TextChar]: ...
